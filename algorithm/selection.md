# 選択アルゴリズムまとめ

長さnの数列{a_n}に対してk番目に小さい値を見つける問題。

## Offline

#### 愚直解
- k回minを取る: O(nk)時間
- sort: O(nlogn)時間

#### 線形解:
- Quick sortの要領でpivotで分けると一方だけ見ればよくなる: 平均O(n)時間
- pivot選択を中央値の中央値（5つずつに分けて、3番目の値を集めて中央値）にすると、理論的にO(n)時間解

#### 近似解:
- q-digest: O(n)時間解
  - 最初に圧縮して木構造を作る
    - セグメントツリーみたいかんじの二分木で各ノードは範囲とカウントを持つ
    - 対応する葉ノードかその祖先のどこかでカウントされる＝圧縮
  - ここからquartileを復元するとoverestimateする
  - 圧縮して木を作るパートがボトルネック
  - 木はマージが簡単にできる -> 圧縮を並列してそのあとマージで並列を有効活用
  - 精度2倍で圧縮後の大きさ2倍
  - https://citeseerx.ist.psu.edu/doc/10.1.1.132.7343
  - HiveとかPrestoのapprox_percentileの実装がこれらしい

bucket解:
- カーディナリティが低いならバケットソートの要領でカウントすれば高速

## Online

- セグメントツリーで頑張る
- 二分木で頑張る
- 平方分割する

でかいデータだとディスク読み込みがつらいので、分岐の多い木で表現するとお得がち。
データベースで表現するのも分岐が少ないほうが楽。
よって計算量的には大きいが、平方分割がお得になりがち。
  